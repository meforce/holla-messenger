"use strict";(self.webpackChunkion_holla_messenger=self.webpackChunkion_holla_messenger||[]).push([[5143],{5143:(F,x,b)=>{b.r(x),b.d(x,{FilesystemWeb:()=>q});var c=b(4553),R=b(8384);function v(h){const p=h.split("/").filter(e=>"."!==e),r=[];return p.forEach(e=>{".."===e&&r.length>0&&".."!==r[r.length-1]?r.pop():r.push(e)}),r.join("/")}let q=(()=>{class h extends R.Uw{constructor(){super(...arguments),this.DB_VERSION=1,this.DB_NAME="Disc",this._writeCmds=["add","put","delete"]}initDb(){var r=this;return(0,c.Z)(function*(){if(void 0!==r._db)return r._db;if(!("indexedDB"in window))throw r.unavailable("This browser doesn't support IndexedDB");return new Promise((e,n)=>{const t=indexedDB.open(r.DB_NAME,r.DB_VERSION);t.onupgradeneeded=h.doUpgrade,t.onsuccess=()=>{r._db=t.result,e(t.result)},t.onerror=()=>n(t.error),t.onblocked=()=>{console.warn("db blocked")}})})()}static doUpgrade(r){const n=r.target.result;switch(r.oldVersion){case 0:case 1:default:n.objectStoreNames.contains("FileStorage")&&n.deleteObjectStore("FileStorage"),n.createObjectStore("FileStorage",{keyPath:"path"}).createIndex("by_folder","folder")}}dbRequest(r,e){var n=this;return(0,c.Z)(function*(){const t=-1!==n._writeCmds.indexOf(r)?"readwrite":"readonly";return n.initDb().then(i=>new Promise((o,s)=>{const a=i.transaction(["FileStorage"],t).objectStore("FileStorage")[r](...e);a.onsuccess=()=>o(a.result),a.onerror=()=>s(a.error)}))})()}dbIndexRequest(r,e,n){var t=this;return(0,c.Z)(function*(){const i=-1!==t._writeCmds.indexOf(e)?"readwrite":"readonly";return t.initDb().then(o=>new Promise((s,d)=>{const l=o.transaction(["FileStorage"],i).objectStore("FileStorage").index(r)[e](...n);l.onsuccess=()=>s(l.result),l.onerror=()=>d(l.error)}))})()}getPath(r,e){const n=void 0!==e?e.replace(/^[/]+|[/]+$/g,""):"";let t="";return void 0!==r&&(t+="/"+r),""!==e&&(t+="/"+n),t}clear(){var r=this;return(0,c.Z)(function*(){(yield r.initDb()).transaction(["FileStorage"],"readwrite").objectStore("FileStorage").clear()})()}readFile(r){var e=this;return(0,c.Z)(function*(){const n=e.getPath(r.directory,r.path),t=yield e.dbRequest("get",[n]);if(void 0===t)throw Error("File does not exist.");return{data:t.content?t.content:""}})()}writeFile(r){var e=this;return(0,c.Z)(function*(){const n=e.getPath(r.directory,r.path),t=r.data,i=r.recursive,o=yield e.dbRequest("get",[n]);if(o&&"directory"===o.type)throw"The supplied path is a directory.";const s=r.encoding,d=n.substr(0,n.lastIndexOf("/"));if(void 0===(yield e.dbRequest("get",[d]))){const l=d.indexOf("/",1);if(-1!==l){const m=d.substr(l);yield e.mkdir({path:m,directory:r.directory,recursive:i})}}const a=Date.now(),u={path:n,folder:d,type:"file",size:t.length,ctime:a,mtime:a,content:!s&&t.indexOf(",")>=0?t.split(",")[1]:t};return yield e.dbRequest("put",[u]),{uri:u.path}})()}appendFile(r){var e=this;return(0,c.Z)(function*(){const n=e.getPath(r.directory,r.path);let t=r.data;const i=n.substr(0,n.lastIndexOf("/")),o=Date.now();let s=o;const d=yield e.dbRequest("get",[n]);if(d&&"directory"===d.type)throw"The supplied path is a directory.";if(void 0===(yield e.dbRequest("get",[i]))){const u=i.indexOf("/",1);if(-1!==u){const l=i.substr(u);yield e.mkdir({path:l,directory:r.directory,recursive:!0})}}void 0!==d&&(t=d.content+t,s=d.ctime);const a={path:n,folder:i,type:"file",size:t.length,ctime:s,mtime:o,content:t};yield e.dbRequest("put",[a])})()}deleteFile(r){var e=this;return(0,c.Z)(function*(){const n=e.getPath(r.directory,r.path);if(void 0===(yield e.dbRequest("get",[n])))throw Error("File does not exist.");if(0!==(yield e.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(n)])).length)throw Error("Folder is not empty.");yield e.dbRequest("delete",[n])})()}mkdir(r){var e=this;return(0,c.Z)(function*(){const n=e.getPath(r.directory,r.path),t=r.recursive,i=n.substr(0,n.lastIndexOf("/")),o=(n.match(/\//g)||[]).length,s=yield e.dbRequest("get",[i]),d=yield e.dbRequest("get",[n]);if(1===o)throw Error("Cannot create Root directory");if(void 0!==d)throw Error("Current directory does already exist.");if(!t&&2!==o&&void 0===s)throw Error("Parent directory must exist");if(t&&2!==o&&void 0===s){const u=i.substr(i.indexOf("/",1));yield e.mkdir({path:u,directory:r.directory,recursive:t})}const y=Date.now(),a={path:n,folder:i,type:"directory",size:0,ctime:y,mtime:y};yield e.dbRequest("put",[a])})()}rmdir(r){var e=this;return(0,c.Z)(function*(){const{path:n,directory:t,recursive:i}=r,o=e.getPath(t,n),s=yield e.dbRequest("get",[o]);if(void 0===s)throw Error("Folder does not exist.");if("directory"!==s.type)throw Error("Requested path is not a directory");const d=yield e.readdir({path:n,directory:t});if(0!==d.files.length&&!i)throw Error("Folder is not empty");for(const y of d.files){const a=`${n}/${y}`;"file"===(yield e.stat({path:a,directory:t})).type?yield e.deleteFile({path:a,directory:t}):yield e.rmdir({path:a,directory:t,recursive:i})}yield e.dbRequest("delete",[o])})()}readdir(r){var e=this;return(0,c.Z)(function*(){const n=e.getPath(r.directory,r.path),t=yield e.dbRequest("get",[n]);if(""!==r.path&&void 0===t)throw Error("Folder does not exist.");return{files:(yield e.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(n)])).map(s=>s.substring(n.length+1))}})()}getUri(r){var e=this;return(0,c.Z)(function*(){const n=e.getPath(r.directory,r.path);let t=yield e.dbRequest("get",[n]);return void 0===t&&(t=yield e.dbRequest("get",[n+"/"])),{uri:(null==t?void 0:t.path)||n}})()}stat(r){var e=this;return(0,c.Z)(function*(){const n=e.getPath(r.directory,r.path);let t=yield e.dbRequest("get",[n]);if(void 0===t&&(t=yield e.dbRequest("get",[n+"/"])),void 0===t)throw Error("Entry does not exist.");return{type:t.type,size:t.size,ctime:t.ctime,mtime:t.mtime,uri:t.path}})()}rename(r){var e=this;return(0,c.Z)(function*(){return e._copy(r,!0)})()}copy(r){var e=this;return(0,c.Z)(function*(){return e._copy(r,!1)})()}requestPermissions(){return(0,c.Z)(function*(){return{publicStorage:"granted"}})()}checkPermissions(){return(0,c.Z)(function*(){return{publicStorage:"granted"}})()}_copy(r,e=!1){var n=this;return(0,c.Z)(function*(){let{toDirectory:t}=r;const{to:i,from:o,directory:s}=r;if(!i||!o)throw Error("Both to and from must be provided");t||(t=s);const d=n.getPath(s,o),y=n.getPath(t,i);if(d===y)return;if(function(h,p){h=v(h),p=v(p);const r=h.split("/"),e=p.split("/");return h!==p&&r.every((n,t)=>n===e[t])}(d,y))throw Error("To path cannot contain the from path");let a;try{a=yield n.stat({path:i,directory:t})}catch(g){const f=i.split("/");f.pop();const _=f.join("/");if(f.length>0&&"directory"!==(yield n.stat({path:_,directory:t})).type)throw new Error("Parent directory of the to path is a file")}if(a&&"directory"===a.type)throw new Error("Cannot overwrite a directory with a file");const u=yield n.stat({path:o,directory:s}),l=function(){var g=(0,c.Z)(function*(f,_,w){const E=n.getPath(t,f),P=yield n.dbRequest("get",[E]);P.ctime=_,P.mtime=w,yield n.dbRequest("put",[P])});return function(_,w,E){return g.apply(this,arguments)}}(),m=u.ctime?u.ctime:Date.now();switch(u.type){case"file":{const g=yield n.readFile({path:o,directory:s});return e&&(yield n.deleteFile({path:o,directory:s})),yield n.writeFile({path:i,directory:t,data:g.data}),void(e&&(yield l(i,m,u.mtime)))}case"directory":{if(a)throw Error("Cannot move a directory over an existing object");try{yield n.mkdir({path:i,directory:t,recursive:!1}),e&&(yield l(i,m,u.mtime))}catch(f){}const g=(yield n.readdir({path:o,directory:s})).files;for(const f of g)yield n._copy({from:`${o}/${f}`,to:`${i}/${f}`,directory:s,toDirectory:t},e);e&&(yield n.rmdir({path:o,directory:s}))}}})()}}return h._debug=!0,h})()}}]);